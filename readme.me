======== Общие принципы ========

Все настройки и константные вещи хранятся в settings.py
Функционал желательно делать в виде отдельных блоков в файлах .py и потом импортить их

======== ========


======== Хироку  ========

Основная работа с ботом происходит на хироку. Это система, которая позволяет отлаживать приложения прямо на себе. Она комплиирует код и ставит все пакеты сама в своей виртуальной файловой системе.
Поэтому вся смена контента происходит через базу, если сохранять что-то на файловой системе, то оно удалится при заливки на хироку, потому что она будет создавать файлы с нуля.
"ВСЕ ДЕЙСВТИЯ С ХИРОКУ ОСУЩЕСТВЛЯЮТСЯ ЧЕРЕЗ КОМАНДНУЮ СТРОКУ В ПАПКЕ С ПРОЕКТОМ ПО АНАЛОГИИ С ГИТОМ"
Для работы с хироку нужен "git". По сути заливка на хироку ничем не отличается от заливки на git. 


Чтобы начать работать с хироку вообще, нужно в нём залогинится, для этого надо ввести команду:
@heroku login
После неё выйдет html форма, в которой нужно будет залогинться и только после этого можно выполнять все ниже описанные команды. 

Чтобы скопировать проект себе на компьютер, необходимо ввести следущую команду:
@heroku git:clone -a dry-crag-91704  для тестового бота
@heroku git:clone -a accelerator-publ для продакшен бота


Чтобы залить изменения на хироку нужно выполнить ряд следующих команд:
@git add .
@git commit -m "текст коммита" 
@git push heroku master
Синтаксис такой же, как у гита, отличается только сервер, на который заливается код. У гита это "origin", а у хироку "heroku".

Чтобы смотреть логи, нужно ввести следующую команду:
@heroku logs --tail 

К хироку подключена postgress и для работы с ней нужно иметь установленный postgress на компьютере. 
Чтобы зайти в базу данных из командной строи нужно ввести следующую команду:
@heroku pg:psql
Примечание: лучше пользоваться линкусовым терминалом или программой terminus (винда), если этого не делать, то вся киррилица написанная на utf-8 будет не читабельной, а добавляемый текст будет
в кодировке windows-1251 и будет уже не читаемой при выводе в бота. Нельзя использовать дефолтный cmd для работы с текстами в базе хироки!

======== ========



======== Связь с базой ========

db_manager.py - содержит класс DbManager
При инциаилизации он парсит ссылку, которая задаётся в глобальной переменной в хироку проекте. ( с помощью этой строки url = urlparse.urlparse(os.environ['DATABASE_URL']) )
С помощью psycopg2 она связывается с postgress базой на хироку.

Описание методов
	get_item - принимает параметры table и where - выдаёт одну первую запись в базе или False
	get_items  - принимает параметры table и where - выдаёт список записей 
	update - принимает параметры table, where и set - обновляет записи в базе (ничего не даёт в ответ)
	query - принимает параметр text - который является текстом запроса - выдаёт список записей
	remove - принимает параметры table и where - удаляет запись (ничего не даёт в ответ)
	close - закрывает соеденине psycopg2

	есть ряд методов добавляющие записи в базу - под каждое добавление отдельный метод
		add_account - добавляет запись в таблицу аккаунт
		add_answer - добавляет запись в таблицу user_answer
		add_lesson - добавляет запись в таблицу lesson
		add_survey - добавляет запись в таблицу survey
		add_agreement - добавляет запись в таблицу agreement_lidogenerator
		add_additional_role - добавляет запись в таблицу user_role_additional
		add_order - добавляет запись в таблицу orders
		add_transaction - добавляет запись в таблицу transactions
		add_user_order - добавляет запись в таблицу user_order

Любые действия с базой должны идти через этот класс.

======== ========



======== Работа с пользователем  ========

Вся работа с пользователем идёт через класс Client
Класс цепляется сразу к 4 таблицам
В нём есть переменные, которые изначально равны False - при инциализации класса в них добавляются dict() 
    user - добавляеся dict() являющийся записью из таблицы account (текущий аккаунт пользователя)
    message = False
    role = добавляеся dict() являющийся записью из таблицы role (текущая роль пользьзователя)
    lesson = добавляеся dict() являющийся записью из таблицы lesson (текущий урок пользователя)
    answer = добавляеся dict() являющийся записью из таблицы user_answer (текущие ответы пользователя на вопросы с последнего урока)
    tran = добавляеся dict() являющийся записью из таблицы user_answer (текущие ответы пользователя на вопросы с последнего урока )
 При инициализации из сообщения берётся логин пользователя в телеге и по нему делается запрос в базу, чтобы достать аккаунт по логину, либо создать его.

 Описание методов
 	authorization_user - проверяет есть ли чат пользователя в базе, если нету - то добавляется. Если у пользователя есть role_id, то подгружается записи из базы в классовую переменную role ( по аналогии происходит с lesson и answer)
 	get_lesson - берёт из гугл таблицы данные по текущему уроку и высылает пользователю, записывает в базу вопросы из гугл таблицы, после чего позапускает фукнцию get_question
 	get_question - выводит вопрос, на который ещё не было ответа либо список всех вопросов с кнопкой отправить на проверку
 	get_question_id - берёт из базы текущее количество ответов и по этому количеству определяет какой должен быть вопрос
 	get_all_answer - соединяет в себе все вопросы и ответы, после чего выводит их строкой
 	get_accounts_by_role - принимает на вход роль, после чего ищет все аккаунты у которых есть эта роль
 	get_role_from_account - показывает все роли определённого аккаунта
 	get_taken_orders - показывает заказы, которые забрал себе лидогенератор
 	set_answer - отправляет ответ на вопросы 
 	set_status - отправляет статус првоерки Трекером заданий ученика
 	send - отправляет сообщение через бота к пользователю в чат
 	send_html - отправляет сообщение поддерживающие html элементы (b, i, u, a) 
 	send_button - отправляет кнопку вместе с текстом
 	send_buttons - отправляет ряд кнопок в одну линию вместе с текстом
 	send_html_buttons - отправляет ряд кнопок в одную линию вместе с текстом поддерижвающие html
 	send_answer - отправляет ответы ученика на проверку проверяющему
 	edit - редактирует текущее сообщение 
 	edit_html - редактирует текущее сообщение с подержкой html
 	delete - удаляет сообщение
 	parse_question - вопросы хранятся в виде строки с разделителем [=_=] - эта функция разделяет строку по этому символу выдавая массив
 	parse_answer - по аналогии с parse_question только для вопросов
 	is_learner - выдаёт True или False - показывает является ли аккаунт учеником
 	is_validator - выдаёт True или False - показывает является ли аккаунт трекером
 	is_startup - выдаёт True или False - показывает принадлежит ли аккаут к группе ролей стартап
 	is_worker - выдаёт True или False - показывает принадлежит ли аккаунт к группе ролей сотрудник
 	is_partner - выдаёт True или False - показывает принаделжит ли аккаут к группе ролей партнёр
 	is_last_question - проверяет является ли вопрос, на который дали овтет последним
 	is_end_lesson - показывает закончился ли урок пользователя (True или False)
 	is_answer_send - показывает отослал ли пользователь ответы на вопросы (True или False)
 	next_lesson - переключает урок на следующий

Этот класс содержится в разных классах и через него лучше отсылать всю информацию относительно бота

======== ========



======== Работа интерфейсом в боте  ========

Весь интерфейс в боте работает через класс Menu.
Этот класс активно использует класс Screen - в котором хранится переменные link, chat_id, message_id, text, buttons. А также метод render, который отсылает сообщение с кнопками. 
Menu - динамически формирует экраны, которые отсылается в телегу сообщением. 
При инициализации получается весь список методов класса и просматривает названия, если в навзании есть screen и dynamic, то он вызывает метод с параметром is_index. При параметре is_index методы screen**dynamic выдают ссылку на этот экран - после чего этот экран инициализируется. 

Основные переменные (указаны дефолтные значения)
	screens = dict() - список всех экранов - хеш ключом является sc_link - указываемый в screen_*_dynamic
    client = False - объект класса Clien()
    new_screen = False - переменная которая говорит о том, создавать менюшку в текущем сообщение или сделать новое
    link = False -текущая ссылка, которая получается из кнопок в телеге (callback_data)

Описание методов
	__get_link_list__ - выдат все ссылки на экраны в виде массива
	events - проверяет все функции screen_*_dynamic и если self.link содерижт элементы из ссылки указанной в screen_*_dynamic она запускается
	redirect - находит в screens по ключу self.link объект класса Screen и вызывает у него метод render - который отправляет сообщение в телегу с преерключёнными кнопками
	one_screen - изменяет переменную new_screen на значение False - новые экраны при таком варианте будут появляться через редактирование старых сообщений
	screens_exist - показывает существует ли скрин
	home - функция главного меню, в ней собираются группы ролей - если у пользователя есть доступ к одной из ролей группы, то кнопка с название группы отображается, если нет то не отображается
	screen_*_dynamic - основной тип функций для работы в этом классе - имеет вид 
		def screen_*_dynamic(self, **kwargs):
	        sc_link = '/ссылка' #все ссылки пишутся через слеш

	        screens_getter = self.screens_getter(sc_link, 'Текст который будет в сообщение, к которому прекрепляются кнопки меню', kwargs) #Телеграм не позволяет отправлять только кнопки, они обятаельно # должны быть привязаны к сообщению

	        if screens_getter: #эта проверка позволяет навешивать дополнительные параметры на функции screen_*_dynamic и менять этим данные, которые они возвращают
	            return screens_getter

	        if not sc_link in self.link: #если линка экрана нет в текущем линке то функция убивается
	            return False

	    эта функция может принимать аргумент is_index, при нём верёнтся массив вида [ссылка на экран, текст прикреплённый к кнопкам]. Также принимает аргумент get_button - при нём функция выдаёт телеграмм кнопку, автоматически указывает в качестве call_back ссылку указанную в функции, button_name - название кнопки
	screens_getter - тут для всех функций определяются возможные выводы при различных параметрах
	get_order_card - выдаёт слайдер заказов
	create_sheet_survey - создаёт запрос с вопросами из гугл таблицы
	get_button - делает кнопку, котоурю потом выводит 
	close - закрывает меню
	just_button - создаёт кнопку

Примеры использвоания:
    def screen_admin_dynamic(self, **kwargs):
        sc_link = '/admin'

        screens_getter = self.screens_getter(sc_link, 'Панель Администратора', kwargs)
        if screens_getter:
            return screens_getter

        if not sc_link in self.link:
            return False

        keyboard = types.InlineKeyboardMarkup()
        keyboard.add(self.just_button('Редактирование заявок \nна лидогенерацию',
                                      '/orders_edit[=_=]' + self.client.user['login']))
        keyboard.add(self.screen_users_edit_dynamic(get_button=True, button_name='Редактирование пользователей'))
        keyboard.add(self.just_button('Редактирование групп ролей', '/role_groups_edit[=_=]' + self.client.user['login']))
        keyboard.add(self.just_button('Редактирование уроков', '/lessons_edit[=_=]' + self.client.user['login']))
        keyboard.add(self.just_button('Редактирование ролей', '/roles_edit[=_=]' + self.client.user['login']))
        keyboard.add(self.just_button('Назад', '/service[=_=]' + self.client.user['login']))
        keyboard.add(self.home(get_button=True, button_name='В главное меню'))
        self.screens[sc_link].buttons = keyboard


    sc_link = '/admin' - эта страка задаёт индивидуальную ссылку экрану

    keyboard = types.InlineKeyboardMarkup() - тут создаётся переменная кейбор, в которой будут храниться все кнопки для меню

    self.screen_users_edit_dynamic(get_button=True, button_name='Редактирование пользователей') - возвращает кнопку telebot.types.InlineKeyboardButton  с ссылкой на экран редактирование пользователей

    self.screens[sc_link].buttons = keyboard - задаёт экрану по ссылке созданные нами кнопки

    это функции достаточно, чтобы появился полностью функцониальный экран, в дополеннии в уже доступном экране нужно создать кнопку self.screen_admin_dynamic(get_button=True, button_name='Админка') и тогда можно будет перейти к созданному экрану и осущетсвлять с ним работу 

======== ========



======== Работа с текстом введёном в чате пользователем  ========

Работа с текстом введённом в чате идёт через следующие методы
	@bot.message_handler(commands=['команда']) reactStart - обратаывает команды, которые пользователь вводит в чат через /
	@bot.callback_query_handler(func=lambda call: True) callback_inline - функция обратаывающая callback_data которая приходит с кнопок
	@bot.message_handler(content_types=['text']) reatNext - функция обрабытвающая обычный текст, который не заявлен в качестве команды в бот фазере
	router - есть во всех функциях и если пользвоатель находится в режиме опроса ретурнится False и остальные функции прекращают переработку информации, а роутер направляет её в Survey либо в функции работающие с опросом ученика после прохождения обучения.

======== ========



======== Работа с контентом  ========

Для работы с контентом используется сложная система - для того, чтобы не создавать сильнйо задержки. 
Весь контент хранится в базе в таблице "content", имеющей поля "id", "key", "text".
	Поле "key" - это уникальный ключ для фразы.
	Поле "text" - это сам текст, который подставляется.

Сами данные, добавляются и редактируются в гугл таблице с столбиками "Ключ (используется в коде)" и "Текст" (ячейки А и В) по аналогии с таблицей в базе. Также рядом в ячейках "Контент в боте" (YZ)
хранится все итемы хранящиеся в базе данных (как бы дублируя первые два столбика). 
При редактировании любой информации запускается скрипт ( называется onEdit ),встроенный в гугл таблицу.

Разбор фрагментов кода из гугл таблицы:
  var ss = SpreadsheetApp.getActiveSpreadsheet(), - задаётся текущее приложение
      current_sheet =ss.getActiveSheet(), - выбирается текущий лист
      second_sheet = ss.getSheets()[1].getName(); - выбирается второй лист
  
  if(current_sheet.getName() != second_sheet) - проверка, для того, чтобы редактирования учитывались только со второго листа, на котором расположен весь контент ( на первом расположены опросы )
    
  var items = current_sheet.getRange("A2:B").getValues(), - берутся все данные из столбиков A и B
  
  items.forEach(function(element) { - цикл по всем записям
    var count = 0;
    element.forEach(function(element_item) { - цикл по двумя ячейкам А и В - если обе ячейки заполнены, то данные добавляюстя в массив update_list. Если есть хотя бы одно такое значение 
    										   переменная is_ready_to_update принимает значение True, если нет то False. Это нужно, чтобы не учитывать не заполненые до конца столбики и
    										   если нет подходящих записей не выполнять дальше скрипт (пустые столбики А и В например). 
  
  if(!is_ready_to_update) - проверка работать ли дальше с полученными данными
    return false
    
  var items = current_sheet.getRange("Y2:Z").getValues(), - берутся старые данные забранные с сервера, на момент добавления прошлого пункта. С ними в последующем будут сравниваться текущие данные,
  														    чтобы лишний раз не напрягать сервер и кидать запрос на добавление в базу, когда есть изменившиеся данные
  
  if(old_list.length > 0) { - из массива с текущими данными, удаляются те, что уже есть на сервере и ни как не отличаются
    old_list.forEach(function(element){
        if(keys[element[0]] != undefined && keys[element[0]].text == element[1] ) {
          ...
          update_list.forEach(function(item) {
          	...
          });
          update_list.splice(id, 1);
        }
    });
  }
  
  if(update_list.length < 1) - проверяется осталось ли в текущем массиве с данными хоть что-то. Если осталось значит есть данные, которых нету на сервере и их можно отправлять.
    return false
    
  update_list.forEach(function(element) { - данные размечаются по принципу, который используется на сервере
    var separator = i < update_list.length? '[=_=]' : '';
    response += element[0] + ':::' + element[1] + separator
  });
  
  var token = 'fXYdpMepXo0fgKlpHSQG'; - этот токен важен, любой запрос без того токена будет игнорироваться сервером
  //работа с хероку
  var data = { - параметры, которые будут отправляться постом
    'token': token,
    'response': response - в "response" хранятся данные на отправку
  };
  var options = {
  	...
  };
  var response = UrlFetchApp.fetch(..."google/sheet/content/set/get_content", options); - запрос на отправку данных
  if(response.getContentText() == 'False') { - если ответ от сервера единственная строка False, то значит на сервере возникла ошибка с добавлением
    ...
  }
  data = {
  	...
  };
  response = UrlFetchApp.fetch(..."google/sheet/content/get/get_content", options);
  if(response.getContentText() == 'False') { - проверка смог ли сервер выдать нам список
    ...
  }
  response_arr = response.getContentText().split('[=_=]'); - строка разбивается на эелменты
  current_sheet.getRange("Y2:Z").clear(); - столбик со старыми данными очищаются
  response_arr.forEach(function(element) { - в этом цикле старый солбик заполняется актуальынми данными с сервера
  	...
  });


На сервере за обработку пост запросов от гугл таблиц отвечают две следующие функции в "deploy.py"
@app.route(get_content_url, methods=['POST'])
def get_content():
	...

@app.route(set_content_url, methods=['POST'])
def set_content():
	...
В этих методах происходят проверки данных и забивание данных в базу. Методы для всех действий используют класс "Content". Также этот класс используется для того, чтобы в коде получать контент из базы.

Переменные класса:
	verify = False - по дефолту класс не верифицирован
    items = False - по дефолту нет итемов

Описание методов класса:
	__init__ - может принимаь на вход "token" и "init_items". Если есть токен то он отправляется в метод set_verify. Если есть init_items, то он вызывает метод get_translate_items
	set_verify - проверяет, равен ли токен, переданный в параметрах заданному в settings.py в переменной "GOOGLE_RESPONSE_TOKEN"
	get_content - забирает все данные из базы, если есть параметр key - то выдаёт одно значение соответствующее ключу, если нету, то все записи из базы
	get_items - забирает данные из базы
	transform_content - трансформирует все базы из записи в формат объекта {'key': 'text', } - для более простого поиска по хешу в дальнейшем
	get_translate_items - берёт все данные из базы с помощью метода get_content и трансформирует их с помощью метода transform_content - заливая результат в переменную класса items
	get_item - если в items есть ключ, соответствующий тому, что передался в функции, он выводит items[key], если нет то заглушку ( этот метод не берёт данные из базы, а работает с уже имеющимися)
	load_item - сначала делает get_translate_items, чтобы обновить данные в переменной items ( вдруг они изменились в базе ) и потом делает get_item по ключу, переданному в параметрах
	set_content - отправляет данные переданные в него в базу ( если они валидны передаёт True, если нет то False ) 

 Использование класса:
 	Помимо функций get_content и set_content в deploy.py класс контент используется в "menu.py" и "client.py"
 	В коде, после импорта инициализируется объект класса - content = Content(token=GOOGLE_RESPONSE_TOKEN, init_items=True). При инициализиации в  него сразу загружаются все данные из базы.
 	В "menu.py"
 		В функциях всегда используется функция  content.get_item() - потому-что она не требует забирание данных из базы и сильно ускоряет скорость загрузки экранов.
 		Для того, чтобы обновлять данные на актуальные в Screen().render() - после отправки сообщения пользователю с экраном запускается функция content.get_translate_items(). Это помогает сильно
 		ускорить работу интерфейса, потому что забор данных из базы происходит. когда пользователю уже пришёл экран и пока он тянется мышкой на нужную кнопку, данные обновляются из базы.
 	В "client.py"
 		По скольку в клиенте нет функции render() как в классе Screen() и реализовать её там не представляются возможной по скольку принцип работы другой, в начале каждой новой функции используется
 		вместо get_item() функция load_item(), которая загружает данные из базы и уже потом, когда данные обновленны используется get_item() во всех следующих случаях забора контента.

======== ========



======== Работа с гугл драйвом  ========



======== ========



======== Работа с парсером  ========



======== ========

